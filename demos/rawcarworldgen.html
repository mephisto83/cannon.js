<html>

<head>
    <title>
        raw car
    </title>
    <style>
        html,
        body {
            margin: 0px;
            padding: 0px;
        }

        body {
            background-color: whitesmoke;
        }

        #displayCanvas {
            border: 1px solid black;
        }
    </style>
    <script type="text/javascript" src="lib/rl.js"></script>
    <script src="carworldfunctions.js"></script>
    <script src="carcomponents.js"></script>
</head>

<body>
    <canvas id="displayCanvas">
        Your browser doesn't support HTML5.
    </canvas>
    <div id="output"></div>
    <script>
        var canvas = null;
        var context = null;
        var searchParams = new URLSearchParams(window.location.search);
        var canvasWidth = parseFloat(searchParams.get('canvasWidth') || 800);
        var canvasHeight = parseFloat(searchParams.get('canvasHeight') || 600);
        var MAX_THRUST = parseFloat(searchParams.get('maxThrust') || .5);
        var MIN_OK = parseFloat(searchParams.get('minok') || 1);
        var MAX_BONUS_THRUST = .57;
        var MAX_AVOIDENCE_THRUST = .60;
        var MAX_FRICTION = parseFloat(searchParams.get('maxFriction') || .095);;
        var AGENT_COUNT = parseFloat(searchParams.get('agents') || 20);
        var MAX_KEEP = parseFloat(searchParams.get('keep') || 10);;
        var NEW_AGENTS = parseFloat(searchParams.get('new') || 1);;
        var VISION_DISTANCE = 2;
        var MAX_DISTANCE_OF_EFFECT = 15;
        var DEAD_DISTANCE = 2.5;
        var DEAD_AFTER = 2;
        var trackWidth = parseFloat(searchParams.get('trackWidth') || 300);;;
        var NUMBER_OF_LEVEL_TRANSITIONS = 6;
        var TRACK_COUNT = parseFloat(searchParams.get('trackSize') || 200);
        var COMPLETE = false;
        const THINK_RATE = 17;
        const RECORDINGS = [];
        var recordings = {

        }
        const TrackCollections = {
        };
        let AGENTS_ORDERED = [];
        window.rememberTrack = false;
        const LEFT = 'LEFT';
        const RIGHT = 'RIGHT';
        const UP = 'UP';
        const DOWN = 'DOWN';
        var best_brains = [];
        var settings = [];
        var current_agents = [];
        try {
            var b = localStorage.getItem('DWD');
            var s = localStorage.getItem('RCW');
            best_brains = JSON.parse(b);
            settings = JSON.parse(s);
        } catch (e) {
            console.log('no brains');
        }
        var DWD = {
            generation: 0
        }

        window.onload = function () {
            canvas = document.getElementById("displayCanvas");
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            MasterStart();
        }
        function MasterStart() {
            canvas = document.getElementById("displayCanvas");
            context = canvas.getContext("2d");

            var game = new Game(canvas, context);

            // Add the canvas boundaries as walls

            game.generateTrack();
            var rlWorld = startRl();
            game.rlWorld = rlWorld;
            game.start();
        }
        function Game(canvas, context) {
            this.canvas = canvas;
            this.context = context;
            this.inputManager = new InputManager(this);
            this.inputManager.init();
            this.clearColor = "#FFFFFF";
            this.walls = [];
            this.actors = [];
            this.hitpoints = [];
            this.tracks = [];
            this.trackMap = {};
        }
        Game.prototype.addToTrackMap = function (left, top, level, step, index) {
            if (this.trackMap[`${left}-${top}-${level}`] //||
                // this.trackMap[`${left}-${top + step}-${level}`] ||
                // this.trackMap[`${left}-${top - step}-${level}`] ||
                // this.trackMap[`${left + step}-${top}-${level}`] ||
                // this.trackMap[`${left - step}-${top}-${level}`]
            ) {
                this.trackMap[`${left}-${top}-${level + 1}`] = { index };
                return level + 1;
            }
            this.trackMap[`${left}-${top}-${level}`] = { index };
            return level;
        }
        Game.prototype.getOption = function (direction) {
            let trackTurnOptions = [];
            switch (direction) {
                case LEFT:
                    trackTurnOptions = [LEFT, UP, DOWN];
                    break;
                case RIGHT:
                    trackTurnOptions = [RIGHT, UP, DOWN];
                    break;
                case UP:
                    trackTurnOptions = [RIGHT, UP, LEFT];
                    break;
                case DOWN:
                    trackTurnOptions = [RIGHT, DOWN, LEFT];
                    break;
            }

            return trackTurnOptions;
        }
        Game.prototype.generateTrack = function (ops) {
            ops = ops || {};
            this.trackMap = {};
            var {
                left = 0,
                top = 0,
                width = trackWidth,
                height = trackWidth,
                trackCount = TRACK_COUNT
            } = ops;
            let game = this;
            var trackMap = {};
            var lastTrack = null;
            var trackBeforeLast = null;
            var currentLevel = 0;
            var me = this;
            var trackTurns = [];
            var samedirection = 0;
            for (var i = 0; i < trackCount; i++) {
                var trackTurnOptions = [LEFT, RIGHT, UP, DOWN];
                if (lastTrack) {
                    trackTurnOptions = this.getOption(lastTrack.direction);
                    if (trackBeforeLast) {
                        var trackBeforeLastOptions = this.getOption(trackBeforeLast.direction);
                        trackTurnOptions = trackTurnOptions.filter(t => trackBeforeLastOptions.indexOf(t) !== -1);
                    }
                }

                var direction = trackTurnOptions[Math.floor(Math.random() * trackTurnOptions.length)];


                if (i === 0) {
                    direction = RIGHT;
                }
                if (window.rememberTrack) {
                    if (window.trackTurns) {
                        direction = window.trackTurns[i];
                    }
                    trackTurns.push(direction);

                }
                var newLevel = me.addToTrackMap(left, top, currentLevel, trackWidth, i);
                samedirection = newLevel !== currentLevel ? NUMBER_OF_LEVEL_TRANSITIONS : 0;
                if (samedirection && lastTrack) {
                    direction = lastTrack.direction;
                    samedirection = samedirection - 1;
                    if (samedirection < 0) {
                        samedirection = 0;
                    }
                }
                var track = new Track(new Point(left, top), new Point(left + width, top + height), direction, newLevel, newLevel !== currentLevel);
                track.index = i;
                currentLevel = newLevel;
                trackBeforeLast = lastTrack;
                lastTrack = track;
                switch (direction) {
                    case LEFT:
                        left = left - width;
                        break;
                    case RIGHT:
                        left = left + width;
                        break;
                    case UP:
                        top = top - height;
                        break;
                    case DOWN:
                        top = top + height;
                        break;
                }

                game.tracks.push(track);
                game.walls.push(...track.walls);
            }
            recordings.track = game.tracks.map(track => track.toJson());
            recordings.actors = {};

            if (window.rememberTrack)
                window.trackTurns = trackTurns;
        }

        Game.prototype.start = function () {
            this.actors = this.rlWorld.agents;
            this.update();
            this.rlWorld.tick();
            if (!window.skipRender)
                this.render();
            if (this.notDone) {
                window.requestAnimationFrame(this.start.bind(this));
            }
            else {
                var best_agents = current_agents.sort((a, b) => {
                    return b.score() - a.score();
                });
                recordings.scores = current_agents.sort((a, b) => {
                    return b.score() - a.score();
                }).map(t => ({ id: t.id, score: t.score() }));
                // best_agents.map(t => console.log(t.score()));
                COMPLETE = false;
                best_brains = best_agents.map(t => {
                    var json = t.brain.toJSON();
                    json.name = t.name;
                    return json;
                });
                settings = best_agents.map(t => t.settings());
                console.log(current_agents.map(t => t.score()));
                DWD.generation++;
                RECORDINGS.unshift(recordings);
                if (RECORDINGS.length > 2) {
                    RECORDINGS.pop();
                }
                recordings = {};
                console.log(`Generation ${DWD.generation}`);
                localStorage.setItem('DWD', JSON.stringify(best_brains.slice(0, 5)));
                localStorage.setItem('RCW', JSON.stringify(settings.slice(0, 5)));
                current_agents = [];
                MasterStart();
            }
        }

        Game.prototype.clear = function () {
            this.context.save();
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            this.context.fillStyle = this.clearColor;
            this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.context.restore();
        }

        Game.prototype.update = function () {
            var mouseX = this.inputManager.mouseX;
            var mouseY = this.inputManager.mouseY;
            this.hitpoints = [];

            var isin = false;
            var tracks = this.tracks;

            this.actors.filter(x => !x.dead).map(actor => {
                actor.update(tracks);
            });
            this.notDone = this.actors.find(x => !x.dead);
            if (this.actors.filter(x => !x.dead).length <= MIN_OK) {
                COMPLETE = true;
            }
            if (COMPLETE) {
                this.notDone = !COMPLETE;
            }
            if (!window.skipRender) {
                var outputs = document.getElementById('output');
                var doc = '';
                var recs = '';
                RECORDINGS.map((record, ri) => {
                    recs += '<div><a id="record' + ri + '">record ' + ri + '</a></div>'
                })
                this.actors.sort((a, b) => {
                    return b.score() - a.score();
                }).filter(x => !x.dead).map((t, ind) => {
                    doc += `<div>${t.name || 'Actor'} ${ind} : (${t.score()})</div>`
                })
                AGENTS_ORDERED = this.actors.filter(x => !x.dead).sort((b, a) => {
                    if (a.trackIndex === b.trackIndex) {
                        return a.lastDistance - b.lastDistance;
                    }
                    return a.trackIndex - b.trackIndex;
                });
                outputs.innerHTML = `<table><tr><td>${doc}</td><td>${recs}</td></tr></table>`;
                const copyToClipboard = str => {
                    const el = document.createElement('textarea');
                    el.value = str;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);
                };
                RECORDINGS.map((record, ri) => {
                    var d = document.getElementById('record' + ri);
                    if (d) {
                        d.addEventListener('click', function () {
                            console.log(`clicked ${ri}`)
                            copyToClipboard(JSON.stringify(record));
                        })
                    }
                });
                window.RECORDINGS = RECORDINGS;
            }
        }

        Game.prototype.render = function () {
            this.clear();
            this.context.save();
            this.context.font = "30px Arial";
            // Render all the walls
            var anAgent = this.actors.find(x => !x.dead);
            var activeLevel = null;
            var currentTrack = null;
            if (anAgent) {
                activeLevel = anAgent.trackLevel();
                currentTrack = anAgent.track;
                this.context.translate(-anAgent.x + canvasWidth / 2, - anAgent.y + canvasHeight / 2);
            }
            else {
                this.context.translate(0, 0);
            }

            for (var i = this.walls.length; i--;) {
                var wall = this.walls[i];
                var lineWidth = 3;
                var skip = false;
                if (!wall.boundary) {
                    if (activeLevel !== null) {
                        if (wall.track && activeLevel === wall.track.level) {
                            var diff = activeLevel - wall.track.level;
                            lineWidth -= diff;
                        }
                        else {
                            skip = true;
                        }
                    }
                    if (!skip) {
                        this.context.lineWidth = wall.open ? 10 : 2;// lineWidth;

                        this.context.strokeStyle = wall.gate ? (wall.open ? "#00FF00" : "#FF0000") : "#000000",
                            this.context.beginPath();
                        this.context.moveTo(wall.p1.x, wall.p1.y);
                        this.context.lineTo(wall.p2.x, wall.p2.y);
                        this.context.stroke();
                        if (wall.position === UP && wall.track) {
                            this.context.lineWidth = 1;// lineWidth;
                            this.context.strokeText(wall.track.index, wall.p1.x + (trackWidth / 4), wall.p1.y + (trackWidth / 4));
                        }
                    }
                }
            }
            //this.context.stroke();
            // Render cursor's position
            this.context.fillStyle = "#FF0000";
            var mouseX = this.inputManager.mouseX;
            var mouseY = this.inputManager.mouseY;
            this.context.fillRect(mouseX - 5, mouseY - 5, 10, 10);
            // Render all the hitpoints
            this.context.fillStyle = "#0000FF";
            var mouseX = this.inputManager.mouseX;
            var mouseY = this.inputManager.mouseY;
            this.context.strokeStyle = "#FF0000",
                this.context.beginPath();
            var size = MAX_DISTANCE_OF_EFFECT;
            for (var i = 0; i < this.hitpoints.length; i++) {
                var hitpoint = this.hitpoints[i];
                this.context.moveTo(mouseX, mouseY);
                this.context.lineTo(hitpoint.x, hitpoint.y);
                this.context.fillRect(hitpoint.x - size / 2, hitpoint.y - size / 2, size, size);
            }
            this.context.stroke();
            // this.context.restore();

            this.context.fillStyle = "#00FF00";
            this.context.beginPath();
            for (var i = 0; i < this.actors.length; i++) {
                var actor = this.actors[i];
                if (activeLevel === actor.trackLevel()) {
                    this.context.fillStyle = window.actorColors[i];
                    this.context.fillRect(actor.x - (size / 2), actor.y - (size / 2), size, size);
                }
            }

            this.context.stroke();
            this.context.restore();
        }

        function Track(p1, p2, direction, level, transitionLevel) {
            var maxx, minx, maxy, miny;
            var me = this;
            this.level = level;
            this.direction = direction;
            this.transitionLevel = transitionLevel;
            [p1, p2].map(point => {
                if (maxx === undefined || maxx < point.x) {
                    maxx = point.x;
                }
                if (maxy === undefined || maxy < point.y) {
                    maxy = point.y;
                }
                if (minx === undefined || minx > point.x) {
                    minx = point.x;
                }
                if (miny === undefined || miny > point.y) {
                    miny = point.y;
                }
            });

            this._center = {
                x: (maxx + minx) / 2,
                y: (maxy + miny) / 2
            }

            var wall_1 = new Wall(new Point(minx - 1, miny - 1), new Point(maxx + 1, miny - 1));

            var wall_2 = new Wall(new Point(maxx + 1, miny - 1), new Point(maxx + 1, maxy + 1));

            var wall_3 = new Wall(new Point(maxx + 1, maxy + 1), new Point(minx - 1, maxy + 1));

            var wall_4 = new Wall(new Point(minx - 1, maxy + 1), new Point(minx - 1, miny - 1));

            this.direction = direction;
            var wall1 = new Wall(new Point(minx, miny), new Point(maxx, miny));
            wall1.open = UP === direction;
            wall1.position = UP;
            wall1.gate = true;
            this.topWall = wall1;

            var wall2 = new Wall(new Point(maxx, miny), new Point(maxx, maxy));
            wall2.open = RIGHT === direction;
            wall2.position = RIGHT;
            wall2.gate = true;
            this.leftWall = wall2;

            var wall3 = new Wall(new Point(maxx, maxy), new Point(minx, maxy));
            wall3.position = DOWN;
            wall3.open = DOWN === direction;
            wall3.gate = true;

            var wall4 = new Wall(new Point(minx, maxy), new Point(minx, miny));
            wall4.open = LEFT === direction;
            wall4.position = LEFT;
            wall4.gate = true;




            this.outerWalls = [wall_1, wall_2, wall_3, wall_4];
            this.outerWalls.map(t => t.boundary = true);
            this.innerWalls = [wall1, wall2, wall3, wall4];
            this.walls = [wall1, wall2, wall3, wall4, ...this.outerWalls].map(t => {
                if (t) {
                    t.track = me;
                }
                return t;
            });

        }
        Track.prototype.toJson = function () {
            return {
                level: this.level,
                transitionLevel: this.transitionLevel,
                wall: this.walls.map(wall => wall.toJson()),
                center: this._center,
                direction: this.direction,
            }
        }
        Track.prototype.center = function () {
            return { ...this._center };
        }
        Track.prototype.isInside = function (item) {
            var mouseX = item.x;
            var mouseY = item.y;
            this.hitpoints = [];
            // For every wall...
            for (var i = 0; i < this.walls.length; i++) {
                var wall = this.walls[i];
                // Cast a ray to every point of the current wall
                for (var j = 0; j < wall.points.length; j++) {
                    var closestPoint = null;
                    if (j == 0) closestPoint = wall.p1;
                    if (j == 1) closestPoint = wall.p2;
                    closestPoint.wall = wall;
                    var ray = new Wall(new Point(mouseX, mouseY), new Point(closestPoint.x, closestPoint.y));
                    var minDistance = ray.length();
                    // Check every wall for intersection
                    var closestWall = null;
                    for (var k = 0; k < this.walls.length; k++) {
                        var checkWall = this.walls[k];
                        if (wall != checkWall) {
                            if (checkWall.intersectsWith(ray)) {
                                // If checkWall intersects with our ray we have to check it's intersection point's distance
                                // If the distance is smaller than the current minimum set intersectionPoint as the closest
                                // point and save the distance.
                                var intersectionPoint = checkWall.intersectionPoint(ray);
                                var tempRay = new Wall(new Point(mouseX, mouseY), new Point(intersectionPoint.x, intersectionPoint.y));
                                if (tempRay.length() < minDistance) {
                                    closestPoint = intersectionPoint;
                                    closestPoint.parent = checkWall;
                                    minDistance = tempRay.length();
                                    closestWall = checkWall;
                                }
                            }
                        }
                    }
                    if (this.outerWalls.indexOf(closestWall) !== -1) {
                        return false;
                    }
                    this.hitpoints.push(closestPoint);
                }
            }
            return [...this.hitpoints];
        }

        function Wall(p1, p2) {
            this.p1 = p1;
            this.open = false;
            this.position = null;
            this.p2 = new Point(p2.x, p2.y);
            this.p1.parent = this;
            this.p2.parent = this;
            this.points = [p1, p2];
            this.center = new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2)
            this.length = function () {
                return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
            }

            this.direction = function () {
                var vLength = this.length();
                return new Point((p2.x - p1.x) / vLength, (p2.y - p1.y) / vLength);
            }
            this.toJson = function () {
                return {
                    open: this.open,
                    position: this.position,
                    p1: p1.toJson(),
                    p2: p2.toJson()
                }
            }

            this.intersectsWith = function (wall) {
                var a = this.p1;
                var b = this.p2;
                var c = wall.p1;
                var d = wall.p2;
                var cmp = new Point(c.x - a.x, c.y - a.y);
                var r = new Point(b.x - a.x, b.y - a.y);
                var s = new Point(d.x - c.x, d.y - c.y);

                var cmpxr = cmp.x * r.y - cmp.y * r.x;
                var cmpxs = cmp.x * s.y - cmp.y * s.x;
                var rxs = r.x * s.y - r.y * s.x;
                if (cmpxr == 0)
                    return ((c.x - a.x < 0) != (c.x - b.x < 0))
                        || ((c.y - a.y < 0) != (c.y - b.y < 0));
                if (rxs == 0)
                    return false;

                var rxsr = 1 / rxs;
                var t = cmpxs * rxsr;
                var u = cmpxr * rxsr;
                return (t >= 0) && (t <= 1) && (u >= 0) && (u <= 1);
            }

            this.intersectionPoint = function (wall) {
                var a = this.p1;
                var b = this.p2;
                var c = wall.p1;
                var d = wall.p2;

                var divider = ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x));
                if (divider == 0)
                    return new Point(0, 0);
                var intersectionX = ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / divider;
                var intersectionY = ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / divider;

                return new Point(intersectionX, intersectionY);
            }
        }

        function Point(x, y) {
            this.x = x;
            this.y = y;
            this.parent = null;
        }
        Point.prototype.toJson = function () {
            return {
                x: this.x,
                y: this.y
            }
        }
        Point.prototype.add = function (point) {
            return new Point(this.x + point.x, this.y + point.y);
        }
        Point.prototype.rotate = function (angle) {
            var ca = Math.cos(angle);
            var sa = Math.sin(angle);
            var rx = this.x * ca - this.y * sa;
            var ry = this.x * sa + this.y * ca;
            return new Point(rx, ry);
        }
        Point.prototype.lerp = function (thrustAmount, to, percentage) {
            return thrustAmount + (to - thrustAmount) * percentage;
        }
        Point.prototype.makeLength = function (len) {
            return new Point(this.x, this.y).unit().multiply(len);
        }
        Point.prototype.multiply = function (l) {
            return new Point(this.x * l, this.y * l);
        }
        Point.prototype.sub = function (point) {
            return new Point(this.x - point.x, this.y - point.y);
        }
        Point.prototype.unit = function () {
            return this.divide(this.length());
        }
        Point.prototype.divide = function (num) {
            if (num < .000001) {
                return new Point(0, 0);
            }
            return new Point(this.x / num, this.y / num);
        }
        Point.prototype.dot = function (p) {
            return this.x * p.x + this.y * p.y;
        }
        Point.prototype.length = function () {
            return Math.sqrt(this.dot(this));
        }
        Point.prototype.neg = function () {
            return new Point(-this.x, -this.y);
        }
        function random_bg_color() {
            var x = Math.floor(Math.random() * 256);
            var y = Math.floor(Math.random() * 256);
            var z = Math.floor(Math.random() * 256);
            var bgColor = "rgb(" + x + "," + y + "," + z + ")";

            return bgColor;
        }
        let ACTORS = 0;
        function Actor(ops) {
            ops = ops || {};
            this.id = ACTORS++;
            var { x = 0, y = 0, thrust = MAX_THRUST, bonusThrust = MAX_BONUS_THRUST, thrustAvoidence = MAX_AVOIDENCE_THRUST, friction = MAX_FRICTION } = ops;
            this.delta = .1;
            this.track = null;
            this.x = x;
            this.name = RACE_CAR_NAMES[Math.floor(Math.random() * RACE_CAR_NAMES.length)];
            this.direction = false;
            this.currentDirection = LEFT;
            this.directionAngle = 0;
            this.turnRate = Math.PI / 50;
            this.color =
                this.y = y;
            this.age = 0;
            this.friction = friction;
            this.speed = {
                x: 0,
                y: 0
            };
            this.passedTargets = [];
            this.offTrack = 0;
            this.stayedTooLong = 0;
            this.targetsPassed = 0;
            this.bonusThrust = bonusThrust;
            this.thrust = thrust + ((MAX_THRUST * .02 * Math.random()));
            this.thrustAvoidence = thrustAvoidence;
            this.upVector = this.upVector || this.rotateVector(0);
            this.downVector = this.downVector || this.rotateVector(Math.PI);
            this.leftVector = this.leftVector || this.rotateVector(-Math.PI / 2);
            this.rightVector = this.rightVector || this.rotateVector(Math.PI / 2);
            this.states = this.initState();
        }

        Actor.prototype = {
            toJson: function toJson() {
                var lastPosition = this.lastPosition;
                var direction = this._direction ? this._direction.unit() : new Point(1, 0);
                if (lastPosition) {
                    direction = this.lastPosition.sub(new Point(this.x, this.y)).unit();
                }
                return {
                    id: this.id,
                    name: this.name,
                    x: this.x,
                    y: this.y,
                    direction,
                    trackIndex: this.trackIndex
                }
            },
            settings: function () {
                return [this.thrust, this.friction, this.thrustAvoidence, this.bonusThrust]
            },
            set: function (settings) {
                this.thrust = settings[0] || MAX_THRUST;
                this.friction = settings[1] || MAX_FRICTION;
                this.thrustAvoidence = settings[2] || MAX_AVOIDENCE_THRUST;
                this.bonusThrust = settings[3] || MAX_BONUS_THRUST;
            },
            rotateVector: function (angle) {
                var x = Math.cos(-(Math.PI / 2) + angle);
                var y = Math.sin(-(Math.PI / 2) + angle);

                return new Point(x, y);
            },
            forward: function () {
                if (this.dead) return;
                var me = this;
                if (this.makeDecision) {
                    // in forward pass the agent simply behaves in the environment
                    // create input to brain
                    var input_array = [LEFT, RIGHT, UP, DOWN].map(t => t === me.currentDirection ? 1 : 0);//new Array(this.num_states);
                    var tdist = trackWidth / 2;
                    var ldist = tdist;
                    var track = this.track || this.lastTrack;
                    if (track.direction) {

                        var topWallPt = track.topWall.points[0];
                        tdist = (Math.abs(this.y - topWallPt.y) / trackWidth) - .5;
                        var topWallPt = track.leftWall.points[0];
                        ldist = (Math.abs(this.y - topWallPt.x) / trackWidth) - .5;
                        var ddist = 1 - tdist;
                        var rdist = 1 - ldist;
                        switch (track.direction) {
                            case LEFT:
                                ldist = 2;
                                break;
                            case UP:
                                tdist = 2;
                                break;
                            case DOWN:
                                ddist = 2;
                                break;
                            case RIGHT:
                                rdist = 2;
                                break;
                        }
                    }
                    // input_array.push(this.directionAngle)
                    input_array.push(tdist);
                    input_array.push(ldist);
                    input_array.push(rdist);
                    input_array.push(ddist);
                    input_array.push(this.speed.x)
                    input_array.push(this.speed.y)
                    // for (var i = 0; i < num_eyes; i++) {
                    //     var offset = 0;
                    //     var e = this.eyes[i];
                    //     input_array.push(e); // velocity information of the sensed target
                    // }

                    var wi = track.walls.map(t => {
                        return t && t.gate && t.open ? 1 : 0;
                    });
                    if (this.tracks) {
                        if (this.tracks.find(x => !x)) {
                            this.dead = true;
                            return;
                        }
                        var me = this;
                        this.tracks.map(_track => {
                            if (_track) {
                                wi = [...wi, ..._track.walls.map(t => {
                                    return t && t.gate && t.open ? 1 : 0;
                                }), ..._track.walls.map(t => {
                                    return ((distance(t.points[0], me) + distance(t.points[1], me)) / trackWidth) - .5;
                                })];
                            }
                            else {
                                wi = [...wi, 0, 0, 0, 0, 0, 0, 0, 0];
                                me.dead = true;
                                return;
                            }
                        })

                    }
                    input_array.push(...wi);
                    this.action = this.brain.act(input_array);
                }
                //var action = this.actions[actionix];
                // demultiplex into behavior variables
                //this.action = action;
            },
            score: function () {
                return this.targetsPassed;
            },
            remove: function () {

            },
            kill: function () {
                if (this.trackIndex > DEAD_AFTER)
                    this.dead = true;
            },
            backward: function () {
                if (this.dead) return;
                var me = this;
                var reward = this.digestion_signal;

                // var proximity_reward = 0.0;
                // var num_eyes = this.eyes.length;
                // for(var i=0;i<num_eyes;i++) {
                //   var e = this.eyes[i];
                //   // agents dont like to see walls, especially up close
                //   proximity_reward += e.sensed_type === 0 ? e.sensed_proximity/e.max_range : 1.0;
                // }
                // proximity_reward = proximity_reward/num_eyes;
                // reward += proximity_reward;

                //var forward_reward = 0.0;
                //if(this.actionix === 0) forward_reward = 1;

                this.last_reward = reward; // for vis
                if (this.makeDecision) {
                    this.brain.learn(reward);
                    this.makeDecision = false;
                }
                me.age = me.age + 1;
            }
        }
        Actor.prototype.initState = function () {
            var me = this;
            return [...new Array(32 + (VISION_DISTANCE * 8)).map(x => 0)];
        }
        Actor.prototype.getMaxNumActions = function () {
            return 4;
        }
        Actor.prototype.getNumStates = function () {
            return this.states.length;
        }
        Actor.prototype.Left = function () {
            this.direction = LEFT;
        }
        Actor.prototype.Right = function () {
            this.direction = RIGHT;
        }
        Actor.prototype.Up = function () {
            this.direction = UP;
        }
        Actor.prototype.Down = function () {
            this.direction = DOWN;
        }
        Actor.prototype.Nothing = function () {
            this.direction = null;
        }
        Actor.prototype.applyAction = function () {
            switch (this.action) {
                case 3:
                    this.Up();
                    break;
                case 2:
                    this.Nothing();
                    break;
                case 1:
                    this.Left();
                    break;
                case 0:
                    this.Right();
                    break;
            }
        }
        Actor.prototype.onTrack = function () {
            return !!this.track;;
        }
        Actor.prototype.trackLevel = function () {
            if (this.track) {
                return this.track.level;
            }
            return null;
        }
        Actor.prototype.updateDirection = function () {
            switch (this.direction) {
                case LEFT:
                    this.currentDirection = LEFT;
                    break;
                case RIGHT:
                    this.currentDirection = RIGHT;
                    break;
                case UP:
                    this.currentDirection = UP;
                    break;
                case DOWN:
                    this.currentDirection = DOWN;
                    break;
                default:
                    break;
            }
        }
        Actor.prototype.getExitDirection = function () {
            if (this.track) {
                switch (this.track.direction) {
                    case UP:
                        this.upVector = this.upVector || this.rotateVector(0);
                        return this.upVector;
                    case DOWN:
                        this.downVector = this.downVector || this.rotateVector(Math.PI);
                        return this.downVector;
                    case LEFT:
                        this.leftVector = this.leftVector || this.rotateVector(-Math.PI / 2);
                        return this.leftVector;
                    case RIGHT:
                        this.rightVector = this.rightVector || this.rotateVector(Math.PI / 2);
                        return this.rightVector;
                }
            }
            this.upVector = this.upVector || this.rotateVector(0);
            return this.upVector;
        }
        Actor.prototype.getAvoidenceVector = function () {
            var me = this;
            var result = new Point(0, 0);
            if (TrackCollections[this.trackIndex] && TrackCollections[this.trackIndex][this.id]) {
                var vector = new Point(me.x, me.y);
                Object.keys(TrackCollections[this.trackIndex]).map(key => {
                    var actor = TrackCollections[me.trackIndex][key];
                    if (key != me.id) {
                        var temp = vector.sub(new Point(actor.x, actor.y));
                        var len = temp.length();
                        if (len < MAX_DISTANCE_OF_EFFECT) {
                            result = result.add(temp.multiply(1 - (Math.pow(len / MAX_DISTANCE_OF_EFFECT, 5))));
                            if (len < DEAD_DISTANCE) {
                                me.kill();
                            }
                        }
                    }
                })
                if (this.track) {
                    this.track.innerWalls.filter(x => !x.open).map(wall => {
                        var temp;
                        switch (this.track.direction) {
                            case LEFT:
                            case RIGHT:
                                temp = vector.sub(new Point(this.x, wall.center.y)).neg();
                                break;
                            case UP:
                            case DOWN:
                                temp = vector.sub(new Point(wall.center.x, this.y));
                                break;
                        }
                        var len = temp.length();
                        if (len < MAX_DISTANCE_OF_EFFECT) {
                            result = result.add(temp.multiply(1 - (Math.pow(len / MAX_DISTANCE_OF_EFFECT, 2))));
                        }
                    })
                }
            }
            return result.unit();
        }
        Actor.prototype.update = function (tracks) {
            if (this.dead) {
                return;
            }
            if (!this.lastPosition || (this.lastPosition.x !== this.x && this.lastPosition.y !== this.y)) {
                if (this.lastPosition) {
                    this._direction = this.lastPosition.sub(new Point(this.x, this.y)).unit();
                }
                this.lastPosition = new Point(this.x, this.y);
            }
            this.updateDirection();
            var avoidVector = this.getAvoidenceVector();
            // var thrustX = this.direction ? this.thrust : 0;
            // var thrustY = this.direction ? 0 : this.thrust;
            var thrustX = 0;
            var thrustY = 0;
            var dir = this.getExitDirection();
            thrustX = this.thrust * dir.x + avoidVector.x * this.thrustAvoidence;
            thrustY = this.thrust * dir.y + avoidVector.y * this.thrustAvoidence;
            var bThrust;
            var refactorThrust = new Point(thrustX, thrustY);
            refactorThrust = refactorThrust.makeLength(this.thrust);
            thrustX = refactorThrust.x;
            thrustY = refactorThrust.y;
            var bonusThrust = this.bonusThrust;
            var pollPosition = AGENTS_ORDERED.indexOf(this);
            if (pollPosition !== -1) {
                bonusThrust = pollPosition / AGENTS_ORDERED.length * bonusThrust;
            }
            switch (this.currentDirection) {
                case LEFT:
                    bThrust = new Point(0, 0);// (this.leftVector.neg()).makeLength(bonusThrust);
                    // thrustX += -this.thrust / 10 * Math.random();
                    break;
                case RIGHT:
                    bThrust = new Point(0, 0);// (this.rightVector.neg().makeLength(bonusThrust));
                    //thrustX += this.thrust / 10 * Math.random();
                    break;
                case UP:
                    bThrust = new Point(0, 0);
                    //thrustY += -this.thrust / 10 * Math.random();
                    break;
                case DOWN:
                    bThrust = new Point(0, 0);
                    //thrustY += this.thrust / 10 * Math.random();
                    break;
            }

            this.speed.x += (-this.friction * this.speed.x) + thrustX + bThrust.x;
            this.speed.y += (-this.friction * this.speed.y) + thrustY + bThrust.y;

            recordings.actors[this.id] = recordings.actors[this.id] || [];
            recordings.actors[this.id].push(this.toJson());
            this.x += this.speed.x;
            this.y += this.speed.y;
            var me = this;
            var lastIndex = this.trackIndex;
            var trackIndex = this.trackIndex;
            if (!this.track || !this.track.isInside(me)) {
                this.track = (this.track ? me.tracks : tracks).find((track, index) => {
                    var ok = false;
                    if (me.track && track && (me.track.transitionLevel || track.transitionLevel) && Math.abs(track.level - me.track.level) <= 1) {
                        ok = true;
                    }
                    else if (me.track && !me.track.transitionLevel && track.level === me.track.level) {
                        ok = true;
                    }
                    if (!me.track || me.track === track) {
                        ok = true;
                    }
                    if (ok) {
                        var isIn = track.isInside(me);
                        if (isIn) {
                            trackIndex = tracks.indexOf(track);
                        }
                        return isIn;
                    }
                    return false;
                });
            }
            this.trackIndex = trackIndex;
            me.tracks = [];
            for (var i = 0; i < VISION_DISTANCE; i++) {
                me.tracks.push(tracks[i + trackIndex]);
            }
            if (trackIndex === tracks.length - 1) {
                COMPLETE = true;
            }
            if (!this.track) {
                //this.dead = true;
                // this.digestion_signal = -1;
                //              this.offTrack = -.1
            }
            else if (this.stayedTooLong < -1) {
                this.dead = true;;
                // this.digestion_signal = -1;
            }
            else {

                this.digestion_signal = 0;
                var nextTrack = me.tracks[1];

                this.makeDecision = true;
                if (this.age % THINK_RATE === 0) {

                    this.makeDecision = true;
                }
                if (this.lastTrack && this.lastTrack !== this.track) {
                    this.digestion_signal = 1;
                    this.lastDistance = null;
                    this.makeDecision = true;
                    if (this.passedTargets.indexOf(this.track) === -1) {
                        this.passedTargets.push(this.track);
                        this.targetsPassed += 1;
                        this.stayedTooLong = 0;
                    }
                    TrackCollections[trackIndex] = TrackCollections[trackIndex] || {};
                    if (TrackCollections[lastIndex] && TrackCollections[lastIndex][this.id]) {
                        delete TrackCollections[lastIndex][this.id];
                    }
                    TrackCollections[trackIndex][this.id] = this;
                }
                else {
                    if (nextTrack) {
                        var targetPoint = nextTrack.center();
                        var currentDistance = distance(targetPoint, this);
                        if (this.lastDistance > currentDistance) {
                            this.digestion_signal = .9;
                            // console.log('down')
                            // this.digestion_signal = trackWidth - currentDistance;
                        }
                        else {
                            // console.log('up')
                            this.digestion_signal = -11.9;
                        }
                        this.lastDistance = currentDistance;
                        this.stayedTooLong += -.001;
                    }
                }

                if (this.track)
                    this.lastTrack = this.track;

            }
        }
        function distance(p2, p1) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
        function InputManager(game) {
            this.game = game;
            this.hoverOver = false;
            this.mouseX = 0;
            this.mouseY = 0;
        }

        InputManager.prototype.init = function () {
            // this.game.canvas.addEventListener("mousemove", this.onMouseMove.bind(this), false);
            // this.game.canvas.addEventListener("mouseover", this.onMouseOver.bind(this), false);
            // this.game.canvas.addEventListener("mouseout", this.onMouseOut.bind(this), false);
        }

        InputManager.prototype.onMouseMove = function (e) {
            var rect = this.game.canvas.getBoundingClientRect();
            this.mouseX = e.clientX - rect.left;
            this.mouseY = e.clientY - rect.top;
        }

        InputManager.prototype.onMouseOver = function (e) {
            this.hoverOver = true;
        }

        InputManager.prototype.onMouseOut = function (e) {
            this.hoverOver = false;
        }

        function startRl() {
            var total_number_of_agents = window.onlyKeepBest ? MAX_KEEP : AGENT_COUNT;
            var row = Math.floor(Math.sqrt(total_number_of_agents));
            var rlService = rl({
                agents: ([...new Array(total_number_of_agents)]).map((t, i) => {
                    var y = Math.floor(i / row);
                    var x = i % row;
                    var agent = new Actor({
                        x: (x * trackWidth / row) + (trackWidth / row / 2),
                        y: (y * trackWidth / row) + (trackWidth / row / 2) + (x % 2 ? trackWidth / row / 4 : -trackWidth / row / 4)
                    });
                    if (best_brains && best_brains[i % total_number_of_agents]) {
                        agent.brainConfig = best_brains[i];
                        agent.name = agent.brainConfig.name;
                    }
                    if (settings && settings[i % total_number_of_agents]) {
                        if (window.onlyKeepBest) {
                            agent.set(settings[i % total_number_of_agents]);
                        }
                        else {
                            if (i < MAX_KEEP) {
                                agent.set(settings[i % total_number_of_agents]);
                            }
                            else if (i < MAX_KEEP + NEW_AGENTS) {
                                agent.set([MAX_THRUST, MAX_FRICTION, MAX_AVOIDENCE_THRUST, MAX_BONUS_THRUST].map(x => {
                                    return x * Math.random();
                                }))
                            }
                            else {
                                var set1 = settings[Math.floor(Math.random() * settings.length)];
                                var set2 = settings[Math.floor(Math.random() * settings.length)];
                                agent.set(set1.map((t, i) => {
                                    if (Math.random() > .5) {
                                        return t;
                                    }
                                    return set2[i];
                                }));
                            }
                        }
                    }
                    else {
                        agent.set([MAX_THRUST, MAX_FRICTION, MAX_AVOIDENCE_THRUST, MAX_BONUS_THRUST].map(x => {
                            return x * Math.random();
                        }))
                    }
                    // agent.world(world);
                    // agent.body(agent_vehicle);
                    // addVehicleVisuals(demo, agent_vehicle);
                    // agent_vehicle.addToWorld(world);
                    // agent.init();


                    agent.applyAction();
                    if (!window.actorColors) {
                        window.actorColors = [...new Array(total_number_of_agents)].map(t => {
                            return random_bg_color();
                        })
                    }
                    current_agents.push(agent);
                    return agent;
                }),
                createTrack: function () {
                },
                createItem: function (item) {
                }
            });
            var world = rlService.start();
            rlService.agents = world.agents;
            return rlService;
        }
        const RACE_CAR_NAMES = [
            "Hammer",
            "Slugs",
            "Prestige",
            "Pitstop",
            "Shadow",
            "Dynamite",
            "Breeze",
            "Rubberburn",
            "Knight",
            "Proto",
            "Starflal",
            "Tank",
            "Frosty",
            "Airjack",
            "Savage",
            "Swifty",
            "Burnout",
            "Gridline",
            "Throttle",
            "Pocket Rocket",
            "Sandbag",
            "Backpain",
            "Earthquake",
            "Holeshot",
            "T-Bone",
            "Magic Feet",
            "Matrix",
            "Shortshift",
            "Lightning",
            "Indy",
            "Goose",
            "Babe",
            "Babe",
            "Nitro",
            "Viper",
            "Indy",
            "Reflex",
            "Wings",
            "Velocity",
            "Lollipop",
            "Buster",
            "Carnage",
            "Rush",
            "Lionheart",
            "Prodigy",
            "Tandem",
            "Shade",
            "Formula Zero",
            "Nemo",
            "Chaser",
            "Dynasty",
            "Scorch",
            "Butch",
            "Rusty",
            "Rusty",
            "Scrub",
            "Rodeo",
            "Bunny",
            "Flopper",
            "Red",
            "Spunk",
            "Duster",
            "Wheelie",
            "Fearless",
            "Thriller",
            "Salty",
            "Twitch",
            "Zoomer",
            "Digger",
            "Blizzard",
            "Typhoon",
            "Diesel",
            "Redline",
            "Skipper",
            "Hunter/Huntress",
            "Brute Force",
            "Clutch",
            "Slingshot",
            "Quickshift",
            "Bolt",
            "Smooth Ride",
            "Spark",
            "Lucky",
            "Dodger",
            "Groovey",
            "Havoc",
            "Grenade",
            "Freebird",
            "Blower",
            "Blondey",
            "Foxy",
            "Showtime",
            "Newbie",
            "Wolf",
            "Chase",
            "Bullet",
            "Fireball",
            "Scooter",
            "Mr/Miss Menace",
            "Kit",
            "Evasive",
            "Handsome",
            "Baby Face",
            "Hybrid",
            "Gogo",
            "Comet",
            "Hurricane",
            "Ace",
            "Speedstar",
            "Maverick",
            "Hotflash",
            "Iceheart",
            "Smokey",
            "Comeback Kid",
            "Frozenheart",
            "Snake",
            "Gravels",
            "Junior",
            "Wheelspin",
            "Zoomzoom",
            "Muscles",
            "Baron/Baroness",
            "Meatball",
            "Rustle",
            "Golden Kid",
            "Fatality",
            "Buddy",
            "Hairpin",
            "Mouse",
            "White Smoke",
            "Apex",
            "Cannonball",
            "Jolt",
            "Jumper",
            "Little Stint",
            "Sprint",
            "Delta",
            "Enigma",
            "Blowover",
            "Lightspeed",
            "Outlaw",
            "Flash",
            "Forza",
            "Prototype",
            "Chopper",
            "Wild Thing",
            "Fury",
            "Straightline",
            "Blue Devil",
            "General",
            "Red Devil",
            "Dodge",
            "Rocketeer",
            "Kid",
            "Glacier",
            "Shakey",
            "Wonderkid",
            "Freestyle",
            "Mongoose",
            "Headway",
            "Xelarate",
            "Zero",
            "Crimson",
            "Bandit",
            "Big Beat",
            "Skip",
            "Kamikaze",
            "Railer",
            "Echelon",
            "Blade",
            "Zigzag",
            "Brute",
            "Bomber",
            "Leadfoot",
            "Colonel",
            "Drift",
            "Turbo",
            "Tasmanian Devil",
            "Blackjack",
            "Swirl",
            "Spirit",
            "Fence",
            "Rubber",
            "Zero Light",
            "The Comeback",
            "Helmet Hair",
            "Lightning Bolt",
            "Drifter",
            "Friction",
            "Momento",
            "Oracle",
            "Mad Max",
            "Honker"
        ]
    </script>
</body>

</html>